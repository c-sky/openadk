--- libunwind-1.2.orig/src/x86/Gos-linux.c	2016-11-18 04:28:29.000000000 +0100
+++ libunwind-1.2/src/x86/Gos-linux.c	2017-04-17 18:57:50.832552016 +0200
@@ -26,6 +26,8 @@ WITH THE SOFTWARE OR THE USE OR OTHER DE
 #include "unwind_i.h"
 #include "offsets.h"
 
+#include <sys/syscall.h>
+
 PROTECTED int
 unw_is_signal_frame (unw_cursor_t *cursor)
 {
@@ -283,26 +285,16 @@ HIDDEN int
 x86_local_resume (unw_addr_space_t as, unw_cursor_t *cursor, void *arg)
 {
   struct cursor *c = (struct cursor *) cursor;
-  ucontext_t *uc = c->uc;
-
-  /* Ensure c->pi is up-to-date.  On x86, it's relatively common to be
-     missing DWARF unwind info.  We don't want to fail in that case,
-     because the frame-chain still would let us do a backtrace at
-     least.  */
-  dwarf_make_proc_info (&c->dwarf);
-
-  if (unlikely (c->sigcontext_format != X86_SCF_NONE))
-    {
-      struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
+  struct sigcontext *sc = (struct sigcontext *) c->sigcontext_addr;
 
-      Debug (8, "resuming at ip=%x via sigreturn(%p)\n", c->dwarf.ip, sc);
-      sigreturn (sc);
-    }
-  else
-    {
-      Debug (8, "resuming at ip=%x via setcontext()\n", c->dwarf.ip);
-      setcontext (uc);
-    }
+  Debug (8, "resuming at ip=%llx via sigreturn(%p)\n",
+             (unsigned long long) c->dwarf.ip, sc);
+  __asm__ __volatile__ (
+			"int $0x80"
+        		: "=r" (sc)
+		        : "0"(SYS_rt_sigreturn)
+		        : "memory"
+  );
   return -UNW_EINVAL;
 }
 #endif
